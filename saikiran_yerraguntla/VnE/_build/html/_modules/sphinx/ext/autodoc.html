
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sphinx.ext.autodoc &#8212; Virtual Node Environment Documentation 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sphinx.ext.autodoc</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sphinx.ext.autodoc</span>
<span class="sd">    ~~~~~~~~~~~~~~~~~~</span>

<span class="sd">    Automatically insert docstrings for functions, classes or whole modules into</span>
<span class="sd">    the doctree, thus avoiding duplication between docstrings and documentation</span>
<span class="sd">    for those who like elaborate docstrings.</span>

<span class="sd">    :copyright: Copyright 2007-2017 by the Sphinx team, see AUTHORS.</span>
<span class="sd">    :license: BSD, see LICENSE for details.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">FunctionType</span><span class="p">,</span> <span class="n">MethodType</span><span class="p">,</span> <span class="n">ModuleType</span>

<span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">PY2</span><span class="p">,</span> <span class="n">iterkeys</span><span class="p">,</span> <span class="n">iteritems</span><span class="p">,</span> <span class="n">itervalues</span><span class="p">,</span> <span class="n">text_type</span><span class="p">,</span> <span class="n">class_types</span><span class="p">,</span> \
    <span class="n">string_types</span><span class="p">,</span> <span class="n">StringIO</span>

<span class="kn">from</span> <span class="nn">docutils</span> <span class="k">import</span> <span class="n">nodes</span>
<span class="kn">from</span> <span class="nn">docutils.utils</span> <span class="k">import</span> <span class="n">assemble_option_dict</span>
<span class="kn">from</span> <span class="nn">docutils.parsers.rst</span> <span class="k">import</span> <span class="n">Directive</span>
<span class="kn">from</span> <span class="nn">docutils.statemachine</span> <span class="k">import</span> <span class="n">ViewList</span>

<span class="kn">import</span> <span class="nn">sphinx</span>
<span class="kn">from</span> <span class="nn">sphinx.util</span> <span class="k">import</span> <span class="n">rpartition</span><span class="p">,</span> <span class="n">force_decode</span>
<span class="kn">from</span> <span class="nn">sphinx.locale</span> <span class="k">import</span> <span class="n">_</span>
<span class="kn">from</span> <span class="nn">sphinx.pycode</span> <span class="k">import</span> <span class="n">ModuleAnalyzer</span><span class="p">,</span> <span class="n">PycodeError</span>
<span class="kn">from</span> <span class="nn">sphinx.application</span> <span class="k">import</span> <span class="n">ExtensionError</span>
<span class="kn">from</span> <span class="nn">sphinx.util</span> <span class="k">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">sphinx.util.nodes</span> <span class="k">import</span> <span class="n">nested_parse_with_titles</span>
<span class="kn">from</span> <span class="nn">sphinx.util.inspect</span> <span class="k">import</span> <span class="n">getargspec</span><span class="p">,</span> <span class="n">isdescriptor</span><span class="p">,</span> <span class="n">safe_getmembers</span><span class="p">,</span> \
    <span class="n">safe_getattr</span><span class="p">,</span> <span class="n">object_description</span><span class="p">,</span> <span class="n">is_builtin_class_method</span><span class="p">,</span> \
    <span class="n">isenumclass</span><span class="p">,</span> <span class="n">isenumattribute</span>
<span class="kn">from</span> <span class="nn">sphinx.util.docstrings</span> <span class="k">import</span> <span class="n">prepare_docstring</span>

<span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
    <span class="c1"># For type annotation</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>  <span class="c1"># NOQA</span>
    <span class="kn">from</span> <span class="nn">docutils.utils</span> <span class="k">import</span> <span class="n">Reporter</span>  <span class="c1"># NOQA</span>
    <span class="kn">from</span> <span class="nn">sphinx.application</span> <span class="k">import</span> <span class="n">Sphinx</span>  <span class="c1"># NOQA</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="kn">import</span> <span class="nn">typing</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">typing</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">typing</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># This type isn&#39;t exposed directly in any modules, but can be found</span>
<span class="c1"># here in most Python versions</span>
<span class="n">MethodDescriptorType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">)</span>


<span class="c1">#: extended signature RE: with explicit module name separated by ::</span>
<span class="n">py_ext_sig_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;^ ([\w.]+::)?            # explicit module name</span>
<span class="sd">          ([\w.]+\.)?            # module and/or class name(s)</span>
<span class="sd">          (\w+)  \s*             # thing name</span>
<span class="sd">          (?: \((.*)\)           # optional: arguments</span>
<span class="sd">           (?:\s* -&gt; \s* (.*))?  #           return annotation</span>
<span class="sd">          )? $                   # and nothing more</span>
<span class="sd">          &#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DefDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A dict that returns a default on nonexisting keys.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="c1"># type: (Any) -&gt; None</span>
        <span class="nb">dict</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># type: (Any) -&gt; Any</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; bool</span>
        <span class="c1"># docutils check &quot;if option_spec&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>  <span class="c1"># for python2 compatibility</span>


<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># type: (Any) -&gt; Any</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">class</span> <span class="nc">Options</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A dict/attribute hybrid that returns None on nonexisting keys.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; Any</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">_MockObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used by autodoc_mock_imports.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; None</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; int</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># type: (str) -&gt; bool</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; None</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># type: (str) -&gt; _MockObject</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># type: (str) -&gt; _MockObject</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; Any</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">MethodType</span><span class="p">]:</span>
            <span class="c1"># Appears to be a decorator, pass through unchanged</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">_MockModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used by autodoc_mock_imports.&quot;&quot;&quot;</span>
    <span class="vm">__file__</span> <span class="o">=</span> <span class="s1">&#39;/dev/null&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="c1"># type: (str, _MockImporter) -&gt; None</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__package__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="n">loader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[str]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__path__</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[str]</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># type: (str) -&gt; _MockObject</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">_MockObject</span><span class="p">()</span>
        <span class="n">o</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">o</span>


<span class="k">class</span> <span class="nc">_MockImporter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="c1"># type: (List[str]) -&gt; None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_packages</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># type: Set[str]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="c1"># Convert module names:</span>
            <span class="c1">#     [&#39;a.b.c&#39;, &#39;d.e&#39;]</span>
            <span class="c1"># to a set of base packages:</span>
            <span class="c1">#     set([&#39;a&#39;, &#39;d&#39;])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_packages</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mocked_modules</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[str]</span>
        <span class="c1"># enable hook by adding itself to meta_path</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">disable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># remove `self` from `sys.meta_path` to disable import hook</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">]</span>
        <span class="c1"># remove mocked modules from sys.modules to avoid side effects after</span>
        <span class="c1"># running auto-documenter</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mocked_modules</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># type: (str, str) -&gt; Any</span>
        <span class="n">base_package</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">base_package</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_packages</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># type: (str) -&gt; ModuleType</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="c1"># module has already been imported, return it</span>
            <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] adding a mock module </span><span class="si">%s</span><span class="s1">!&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">_MockModule</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mocked_modules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">module</span>


<span class="n">ALL</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">INSTANCEATTR</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">members_option</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="c1"># type: (Any) -&gt; Union[object, List[unicode]]</span>
    <span class="sd">&quot;&quot;&quot;Used to convert the :members: option to auto directives.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ALL</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">members_set_option</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="c1"># type: (Any) -&gt; Union[object, Set[unicode]]</span>
    <span class="sd">&quot;&quot;&quot;Used to convert the :members: option to auto directives.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ALL</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">))</span>


<span class="n">SUPPRESS</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">annotation_option</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="c1"># type: (Any) -&gt; Any</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># suppress showing the representation of the object</span>
        <span class="k">return</span> <span class="n">SUPPRESS</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arg</span>


<span class="k">def</span> <span class="nf">bool_option</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="c1"># type: (Any) -&gt; bool</span>
    <span class="sd">&quot;&quot;&quot;Used to convert flag options to auto directives.  (Instead of</span>
<span class="sd">    directives.flag(), which returns None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">AutodocReporter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A reporter replacement that assigns the correct source name</span>
<span class="sd">    and line number to a system message, as recorded in a ViewList.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">viewlist</span><span class="p">,</span> <span class="n">reporter</span><span class="p">):</span>
        <span class="c1"># type: (ViewList, Reporter) -&gt; None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewlist</span> <span class="o">=</span> <span class="n">viewlist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reporter</span> <span class="o">=</span> <span class="n">reporter</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; Any</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reporter</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">system_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># type: (int, unicode, Any, Any) -&gt; nodes.system_message</span>
        <span class="k">if</span> <span class="s1">&#39;line&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s1">&#39;source&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlist</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">]]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reporter</span><span class="o">.</span><span class="n">system_message</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span>
                                            <span class="o">*</span><span class="n">children</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; nodes.system_message</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reporter</span><span class="o">.</span><span class="n">debug_flag</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_message</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; nodes.system_message</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_message</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; nodes.system_message</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_message</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; nodes.system_message</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_message</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">severe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; nodes.system_message</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_message</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># Some useful event listener factories for autodoc-process-docstring.</span>

<div class="viewcode-block" id="cut_lines"><a class="viewcode-back" href="../../../sphinx/doc/ext/autodoc.html#sphinx.ext.autodoc.cut_lines">[docs]</a><span class="k">def</span> <span class="nf">cut_lines</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># type: (int, int, unicode) -&gt; Callable</span>
    <span class="sd">&quot;&quot;&quot;Return a listener that removes the first *pre* and last *post*</span>
<span class="sd">    lines of every docstring.  If *what* is a sequence of strings,</span>
<span class="sd">    only docstrings of a type in *what* will be processed.</span>

<span class="sd">    Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::</span>

<span class="sd">       from sphinx.ext.autodoc import cut_lines</span>
<span class="sd">       app.connect(&#39;autodoc-process-docstring&#39;, cut_lines(4, what=[&#39;module&#39;]))</span>

<span class="sd">    This can (and should) be used in place of :confval:`automodule_skip_lines`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">what_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="c1"># type: (Sphinx, unicode, unicode, Any, Any, List[unicode]) -&gt; None</span>
        <span class="k">if</span> <span class="n">what</span> <span class="ow">and</span> <span class="n">what_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">del</span> <span class="n">lines</span><span class="p">[:</span><span class="n">pre</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">post</span><span class="p">:</span>
            <span class="c1"># remove one trailing blank line.</span>
            <span class="k">if</span> <span class="n">lines</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="n">post</span><span class="p">:]</span>
        <span class="c1"># make sure there is a blank line at the end</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">process</span></div>


<div class="viewcode-block" id="between"><a class="viewcode-back" href="../../../sphinx/doc/ext/autodoc.html#sphinx.ext.autodoc.between">[docs]</a><span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepempty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># type: (unicode, Sequence[unicode], bool, bool) -&gt; Callable</span>
    <span class="sd">&quot;&quot;&quot;Return a listener that either keeps, or if *exclude* is True excludes,</span>
<span class="sd">    lines between lines that match the *marker* regular expression.  If no line</span>
<span class="sd">    matches, the resulting docstring would be empty, so no change will be made</span>
<span class="sd">    unless *keepempty* is true.</span>

<span class="sd">    If *what* is a sequence of strings, only docstrings of a type in *what* will</span>
<span class="sd">    be processed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">marker_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">what_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="c1"># type: (Sphinx, unicode, unicode, Any, Any, List[unicode]) -&gt; None</span>
        <span class="k">if</span> <span class="n">what</span> <span class="ow">and</span> <span class="n">what_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delete</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">exclude</span>
        <span class="n">orig_lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orig_lines</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">delete</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">deleted</span><span class="p">)</span>
                <span class="n">deleted</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">marker_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="n">delete</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">delete</span>
                <span class="k">if</span> <span class="n">delete</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">deleted</span><span class="p">)</span>
                    <span class="n">deleted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lines</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keepempty</span><span class="p">:</span>
            <span class="n">lines</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">orig_lines</span>
        <span class="c1"># make sure there is a blank line at the end</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">process</span></div>


<span class="k">def</span> <span class="nf">format_annotation</span><span class="p">(</span><span class="n">annotation</span><span class="p">):</span>
    <span class="c1"># type: (Any) -&gt; str</span>
    <span class="sd">&quot;&quot;&quot;Return formatted representation of a type annotation.</span>

<span class="sd">    Show qualified names for types and additional details for types from</span>
<span class="sd">    the ``typing`` module.</span>

<span class="sd">    Displaying complex types from ``typing`` relies on its private API.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">typing</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">TypeVar</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">if</span> <span class="n">annotation</span> <span class="o">==</span> <span class="bp">Ellipsis</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;...&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>

    <span class="n">qualified_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="vm">__qualname__</span>  <span class="c1"># type: ignore</span>
                      <span class="k">if</span> <span class="n">annotation</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="n">annotation</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;builtins&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="vm">__qualname__</span>  <span class="c1"># type: ignore</span>
    <span class="k">elif</span> <span class="n">typing</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typing</span><span class="p">,</span> <span class="s1">&#39;GenericMeta&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">GenericMeta</span><span class="p">):</span>
            <span class="c1"># In Python 3.5.2+, all arguments are stored in __args__,</span>
            <span class="c1"># whereas __parameters__ only contains generic parameters.</span>
            <span class="c1">#</span>
            <span class="c1"># Prior to Python 3.5.2, __args__ is not available, and all</span>
            <span class="c1"># arguments are in __parameters__.</span>
            <span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__args__&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__args__</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__args__</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># typing.Callable</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">format_annotation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__args__</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">format_annotation</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[[</span><span class="si">%s</span><span class="s1">], </span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qualified_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">):</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__parameters__</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">format_annotation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qualified_name</span><span class="p">,</span> <span class="n">param_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typing</span><span class="p">,</span> <span class="s1">&#39;UnionMeta&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">UnionMeta</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__union_params__&#39;</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__union_params__</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">format_annotation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qualified_name</span><span class="p">,</span> <span class="n">param_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typing</span><span class="p">,</span> <span class="s1">&#39;CallableMeta&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">CallableMeta</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">getattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__args__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__result__&#39;</span><span class="p">):</span>
            <span class="c1"># Skipped in the case of plain typing.Callable</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__args__</span>
            <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">qualified_name</span>
            <span class="k">elif</span> <span class="n">args</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                <span class="n">args_str</span> <span class="o">=</span> <span class="s1">&#39;...&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formatted_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">format_annotation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
                <span class="n">args_str</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formatted_args</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qualified_name</span><span class="p">,</span>
                                   <span class="n">args_str</span><span class="p">,</span>
                                   <span class="n">format_annotation</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">__result__</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typing</span><span class="p">,</span> <span class="s1">&#39;TupleMeta&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">TupleMeta</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__tuple_params__&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="s1">&#39;__tuple_use_ellipsis__&#39;</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__tuple_params__</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_annotation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__tuple_use_ellipsis__</span><span class="p">:</span>
                    <span class="n">param_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qualified_name</span><span class="p">,</span>
                                   <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_strings</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qualified_name</span>


<span class="k">def</span> <span class="nf">formatargspec</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">varkw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">kwonlyargs</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwonlydefaults</span><span class="o">=</span><span class="p">{},</span> <span class="n">annotations</span><span class="o">=</span><span class="p">{}):</span>
    <span class="c1"># type: (Callable, Tuple[str, ...], str, str, Any, Tuple, Dict, Dict[str, Any]) -&gt; str</span>
    <span class="sd">&quot;&quot;&quot;Return a string representation of an ``inspect.FullArgSpec`` tuple.</span>

<span class="sd">    An enhanced version of ``inspect.formatargspec()`` that handles typing</span>
<span class="sd">    annotations better.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">format_arg_with_annotation</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="c1"># type: (str) -&gt; str</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">format_annotation</span><span class="p">(</span><span class="n">get_annotation</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">get_annotation</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="c1"># type: (str) -&gt; str</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">annotations</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">introspected_hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="n">introspected_hints</span> <span class="o">=</span> <span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                          <span class="k">if</span> <span class="n">typing</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s1">&#39;__code__&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="p">{})</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span>

    <span class="n">formatted</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">defaults_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span> <span class="k">if</span> <span class="n">defaults</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">arg_fd</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># support tupled arguments list (only for py2): def foo((x, y))</span>
            <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span>
            <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format_arg_with_annotation</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
                <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format_arg_with_annotation</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
            <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format_arg_with_annotation</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">defaults</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">defaults_start</span><span class="p">:</span>
                <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; = &#39;</span> <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">annotations</span> <span class="k">else</span> <span class="s1">&#39;=&#39;</span><span class="p">)</span>
                <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">object_description</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">defaults_start</span><span class="p">]))</span>  <span class="c1"># type: ignore</span>
        <span class="n">formatted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_fd</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">varargs</span><span class="p">:</span>
        <span class="n">formatted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">format_arg_with_annotation</span><span class="p">(</span><span class="n">varargs</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">kwonlyargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">varargs</span><span class="p">:</span>
            <span class="n">formatted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwonlyargs</span><span class="p">:</span>
            <span class="n">arg_fd</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
            <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format_arg_with_annotation</span><span class="p">(</span><span class="n">kwarg</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">kwonlydefaults</span> <span class="ow">and</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwonlydefaults</span><span class="p">:</span>
                <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; = &#39;</span> <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">annotations</span> <span class="k">else</span> <span class="s1">&#39;=&#39;</span><span class="p">)</span>
                <span class="n">arg_fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">object_description</span><span class="p">(</span><span class="n">kwonlydefaults</span><span class="p">[</span><span class="n">kwarg</span><span class="p">]))</span>  <span class="c1"># type: ignore</span>
            <span class="n">formatted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_fd</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">varkw</span><span class="p">:</span>
        <span class="n">formatted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">format_arg_with_annotation</span><span class="p">(</span><span class="n">varkw</span><span class="p">))</span>

    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formatted</span><span class="p">))</span>
    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;return&#39;</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; -&gt; &#39;</span><span class="p">)</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format_annotation</span><span class="p">(</span><span class="n">get_annotation</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">fd</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Documenter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Documenter knows how to autodocument a single object type.  When</span>
<span class="sd">    registered with the AutoDirective, it will be used to document objects</span>
<span class="sd">    of that type when needed by autodoc.</span>

<span class="sd">    Its *objtype* attribute selects what auto directive it is assigned to</span>
<span class="sd">    (the directive name is &#39;auto&#39; + objtype), and what directive it generates</span>
<span class="sd">    by default, though that can be overridden by an attribute called</span>
<span class="sd">    *directivetype*.</span>

<span class="sd">    A Documenter has an *option_spec* that works like a docutils directive&#39;s;</span>
<span class="sd">    in fact, it will be used to parse an auto directive&#39;s options that matches</span>
<span class="sd">    the documenter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#: name by which the directive is called (auto...) and the default</span>
    <span class="c1">#: generated directive name</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;object&#39;</span>
    <span class="c1">#: indentation by which to indent the directive content</span>
    <span class="n">content_indent</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;   &#39;</span>
    <span class="c1">#: priority if multiple documenters return True from can_document_member</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#: order if autodoc_member_order is set to &#39;groupwise&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#: true if the generated content may contain titles</span>
    <span class="n">titles_allowed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">option_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;noindex&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">}</span>  <span class="c1"># type: Dict[unicode, Callable]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_attr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">defargs</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, Any) -&gt; Any</span>
        <span class="sd">&quot;&quot;&quot;getattr() override for types such as Zope interfaces.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">typ</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">AutoDirective</span><span class="o">.</span><span class="n">_special_attrgetters</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">defargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">safe_getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">defargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="sd">&quot;&quot;&quot;Called to see if a member can be documented by this documenter.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;must be implemented in subclasses&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directive</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="c1"># type: (Directive, unicode, unicode) -&gt; None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directive</span> <span class="o">=</span> <span class="n">directive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">directive</span><span class="o">.</span><span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">directive</span><span class="o">.</span><span class="n">genopt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">=</span> <span class="n">indent</span>
        <span class="c1"># the module and object path within the module, and the fully</span>
        <span class="c1"># qualified name (all set after resolve_name succeeds)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modname</span> <span class="o">=</span> <span class="kc">None</span>         <span class="c1"># type: str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>          <span class="c1"># type: ModuleType</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span> <span class="o">=</span> <span class="kc">None</span>         <span class="c1"># type: List[unicode]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># type: unicode</span>
        <span class="c1"># extra signature items (arguments and return annotation,</span>
        <span class="c1"># also set after resolve_name succeeds)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># type: unicode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retann</span> <span class="o">=</span> <span class="kc">None</span>          <span class="c1"># type: unicode</span>
        <span class="c1"># the object to document (set after import_object succeeds)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object</span> <span class="o">=</span> <span class="kc">None</span>          <span class="c1"># type: Any</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_name</span> <span class="o">=</span> <span class="kc">None</span>     <span class="c1"># type: unicode</span>
        <span class="c1"># the parent/owner of the object to document</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>          <span class="c1"># type: Any</span>
        <span class="c1"># the module analyzer to get at attribute docs, or None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># type: Any</span>

    <span class="k">def</span> <span class="nf">add_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="o">*</span><span class="n">lineno</span><span class="p">):</span>
        <span class="c1"># type: (unicode, unicode, int) -&gt; None</span>
        <span class="sd">&quot;&quot;&quot;Append one line of generated reST to the output.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">+</span> <span class="n">line</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="o">*</span><span class="n">lineno</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># type: (str, Any, str, Any) -&gt; Tuple[str, List[unicode]]</span>
        <span class="sd">&quot;&quot;&quot;Resolve the module and name of the object to document given by the</span>
<span class="sd">        arguments and the current module/class.</span>

<span class="sd">        Must return a pair of the module name and a chain of attributes; for</span>
<span class="sd">        example, it would return ``(&#39;zipfile&#39;, [&#39;ZipFile&#39;, &#39;open&#39;])`` for the</span>
<span class="sd">        ``zipfile.ZipFile.open`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;must be implemented in subclasses&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; bool</span>
        <span class="sd">&quot;&quot;&quot;Determine what module to import and what attribute to document.</span>

<span class="sd">        Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,</span>
<span class="sd">        *self.args* and *self.retann* if parsing and resolving was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first, parse the definition -- auto directives for classes and</span>
        <span class="c1"># functions can contain a signature which is then used instead of</span>
        <span class="c1"># an autogenerated one</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">explicit_modname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">retann</span> <span class="o">=</span> \
                <span class="n">py_ext_sig_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;invalid signature for auto</span><span class="si">%s</span><span class="s1"> (</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># support explicit module and class name separation via ::</span>
        <span class="k">if</span> <span class="n">explicit_modname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">explicit_modname</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="n">path</span> <span class="ow">and</span> <span class="n">path</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retann</span> <span class="o">=</span> <span class="n">retann</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modname</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span> <span class="ow">and</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; bool</span>
        <span class="sd">&quot;&quot;&quot;Import the object given by *self.modname* and *self.objpath* and set</span>
<span class="sd">        it as *self.object*.</span>

<span class="sd">        Returns True if successful, False if an error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] from </span><span class="si">%s</span><span class="s1"> import </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">))</span>
        <span class="c1"># always enable mock import hook</span>
        <span class="c1"># it will do nothing if autodoc_mock_imports is empty</span>
        <span class="n">import_hook</span> <span class="o">=</span> <span class="n">_MockImporter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">autodoc_mock_imports</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] import </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">ImportWarning</span><span class="p">)</span>
                <span class="nb">__import__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">)</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] =&gt; </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] getattr(_, </span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] =&gt; </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">object_name</span> <span class="o">=</span> <span class="n">part</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># this used to only catch SyntaxError, ImportError and AttributeError,</span>
        <span class="c1"># but importing modules with side effects can raise all kinds of errors</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="ne">SystemExit</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s1">&#39;autodoc: failed to import </span><span class="si">%s</span><span class="s1"> </span><span class="si">%r</span><span class="s1"> from module </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> \
                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objtype</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s1">&#39;autodoc: failed to import </span><span class="si">%s</span><span class="s1"> </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> \
                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">SystemExit</span><span class="p">):</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;; the module executes module level statement &#39;</span> <span class="o">+</span>
                           <span class="s1">&#39;and it might call sys.exit().&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s1">&#39;; the following exception was raised:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> \
                          <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="n">errmsg</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">note_reread</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">import_hook</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_real_modname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; str</span>
        <span class="sd">&quot;&quot;&quot;Get the real module name of an object to document.</span>

<span class="sd">        It can differ from the name of the module through which the object was</span>
<span class="sd">        imported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span>

    <span class="k">def</span> <span class="nf">check_module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; bool</span>
        <span class="sd">&quot;&quot;&quot;Check if *self.object* is really defined in the module given by</span>
<span class="sd">        *self.modname*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">imported_members</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">modname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">modname</span> <span class="ow">and</span> <span class="n">modname</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">format_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="sd">&quot;&quot;&quot;Format the argument signature of *self.object*.</span>

<span class="sd">        Should return None if the object does not have a signature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">format_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="sd">&quot;&quot;&quot;Format the name of *self.object*.</span>

<span class="sd">        This normally should be something that can be parsed by the generated</span>
<span class="sd">        directive, but doesn&#39;t need to be (Sphinx will display it unparsed</span>
<span class="sd">        then).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># normally the name doesn&#39;t contain the module (except for module</span>
        <span class="c1"># directives of course)</span>
        <span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span>

    <span class="k">def</span> <span class="nf">format_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="sd">&quot;&quot;&quot;Format the signature (arguments and return annotation) of the object.</span>

<span class="sd">        Let the user process it via the ``autodoc-process-signature`` event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># signature given explicitly</span>
            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>  <span class="c1"># type: unicode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># try to introspect the signature</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_args</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;error while formatting arguments for &#39;</span>
                                    <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
                <span class="n">args</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">retann</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retann</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">emit_firstresult</span><span class="p">(</span>
            <span class="s1">&#39;autodoc-process-signature&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">retann</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">retann</span> <span class="o">=</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">retann</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39; -&gt; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">retann</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; None</span>
        <span class="sd">&quot;&quot;&quot;Add the directive header and options to the generated content.&quot;&quot;&quot;</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">,</span> <span class="s1">&#39;py&#39;</span><span class="p">)</span>
        <span class="n">directive</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;directivetype&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objtype</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_name</span><span class="p">()</span>
        <span class="n">sourcename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sourcename</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;.. </span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">:: </span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">directive</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sig</span><span class="p">),</span>
                      <span class="n">sourcename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">noindex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   :noindex:&#39;</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">:</span>
            <span class="c1"># Be explicit about the module, this is necessary since .. class::</span>
            <span class="c1"># etc. don&#39;t support a prepended module name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   :module: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># type: (unicode, int) -&gt; List[List[unicode]]</span>
        <span class="sd">&quot;&quot;&quot;Decode and return lines of the docstring(s) for the object.&quot;&quot;&quot;</span>
        <span class="n">docstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># make sure we have Unicode docstrings, then sanitize and split</span>
        <span class="c1"># into lines</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="n">text_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">prepare_docstring</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># this will not trigger on Py3</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">prepare_docstring</span><span class="p">(</span><span class="n">force_decode</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="n">encoding</span><span class="p">),</span>
                                      <span class="n">ignore</span><span class="p">)]</span>
        <span class="c1"># ... else it is something strange, let&#39;s ignore it</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">process_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docstrings</span><span class="p">):</span>
        <span class="c1"># type: (List[List[unicode]]) -&gt; Iterator[unicode]</span>
        <span class="sd">&quot;&quot;&quot;Let the user process the docstrings before adding them.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">docstringlines</span> <span class="ow">in</span> <span class="n">docstrings</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">app</span><span class="p">:</span>
                <span class="c1"># let extensions preprocess docstrings</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s1">&#39;autodoc-process-docstring&#39;</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">objtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">docstringlines</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">docstringlines</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">line</span>

    <span class="k">def</span> <span class="nf">get_sourcename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">:</span>
            <span class="c1"># prevent encoding errors when the file name is non-ASCII</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">srcname</span><span class="p">,</span> <span class="n">text_type</span><span class="p">):</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">srcname</span><span class="p">,</span>
                                     <span class="n">sys</span><span class="o">.</span><span class="n">getfilesystemencoding</span><span class="p">(),</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">srcname</span>
            <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">:docstring of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;docstring of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span>

    <span class="k">def</span> <span class="nf">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="p">,</span> <span class="n">no_docstring</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (Any, bool) -&gt; None</span>
        <span class="sd">&quot;&quot;&quot;Add content from docstrings, attribute documentation and user.&quot;&quot;&quot;</span>
        <span class="c1"># set sourcename and add content from attribute documentation</span>
        <span class="n">sourcename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sourcename</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">:</span>
            <span class="n">attr_docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">find_attr_docs</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">attr_docs</span><span class="p">:</span>
                    <span class="n">no_docstring</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">docstrings</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr_docs</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_doc</span><span class="p">(</span><span class="n">docstrings</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># add content from docstrings</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">no_docstring</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">encoding</span>
            <span class="n">docstrings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_doc</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">docstrings</span><span class="p">:</span>
                <span class="c1"># append at least a dummy docstring, so that the event</span>
                <span class="c1"># autodoc-process-docstring is fired and can add some</span>
                <span class="c1"># content if desired</span>
                <span class="n">docstrings</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_doc</span><span class="p">(</span><span class="n">docstrings</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># add additional content (e.g. from document), if present</span>
        <span class="k">if</span> <span class="n">more_content</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">more_content</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">more_content</span><span class="o">.</span><span class="n">items</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">src</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_object_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">want_all</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; Tuple[bool, List[Tuple[unicode, object]]]</span>
        <span class="sd">&quot;&quot;&quot;Return `(members_check_module, members)` where `members` is a</span>
<span class="sd">        list of `(membername, member)` pairs of the members of *self.object*.</span>

<span class="sd">        If *want_all* is True, return all members.  Else, only return those</span>
<span class="sd">        members given by *self.options.members* (which may also be none).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">analyzed_member_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">:</span>
            <span class="n">attr_docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">find_attr_docs</span><span class="p">()</span>
            <span class="n">namespace</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">attr_docs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">namespace</span><span class="p">:</span>
                    <span class="n">analyzed_member_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">want_all</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[]</span>
            <span class="c1"># specific members given</span>
            <span class="n">members</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">members</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="n">mname</span><span class="p">)))</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">analyzed_member_names</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;missing attribute </span><span class="si">%s</span><span class="s1"> in object </span><span class="si">%s</span><span class="s1">&#39;</span>
                                            <span class="o">%</span> <span class="p">(</span><span class="n">mname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">inherited_members</span><span class="p">:</span>
            <span class="c1"># safe_getmembers() uses dir() which pulls in members from all</span>
            <span class="c1"># base classes</span>
            <span class="n">members</span> <span class="o">=</span> <span class="n">safe_getmembers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="n">attr_getter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># __dict__ contains only the members directly defined in</span>
            <span class="c1"># the class (but get them via getattr anyway, to e.g. get</span>
            <span class="c1"># unbound method objects instead of function objects);</span>
            <span class="c1"># using list(iterkeys()) because apparently there are objects for which</span>
            <span class="c1"># __dict__ changes while getting attributes</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">members</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">members</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="n">mname</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">mname</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterkeys</span><span class="p">(</span><span class="n">obj_dict</span><span class="p">))]</span>

            <span class="c1"># Py34 doesn&#39;t have enum members in __dict__.</span>
            <span class="k">if</span> <span class="n">isenumclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">):</span>
                <span class="n">members</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">__members__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span>
                <span class="p">)</span>

        <span class="n">membernames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">members</span><span class="p">)</span>
        <span class="c1"># add instance attributes from the analyzer</span>
        <span class="k">for</span> <span class="n">aname</span> <span class="ow">in</span> <span class="n">analyzed_member_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">membernames</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">want_all</span> <span class="ow">or</span> <span class="n">aname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">members</span><span class="p">):</span>
                <span class="n">members</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">aname</span><span class="p">,</span> <span class="n">INSTANCEATTR</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">members</span><span class="p">,</span> <span class="n">want_all</span><span class="p">):</span>
        <span class="c1"># type: (List[Tuple[unicode, Any]], bool) -&gt; List[Tuple[unicode, Any, bool]]</span>
        <span class="sd">&quot;&quot;&quot;Filter the given member list.</span>

<span class="sd">        Members are skipped if</span>

<span class="sd">        - they are private (except if given explicitly or the private-members</span>
<span class="sd">          option is set)</span>
<span class="sd">        - they are special methods (except if given explicitly or the</span>
<span class="sd">          special-members option is set)</span>
<span class="sd">        - they are undocumented (except if the undoc-members option is set)</span>

<span class="sd">        The user can override the skipping decision by connecting to the</span>
<span class="sd">        ``autodoc-skip-member`` event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># search for members in source code too</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">)</span>  <span class="c1"># will be empty for modules</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">:</span>
            <span class="n">attr_docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">find_attr_docs</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attr_docs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># process members and determine which to skip</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">membername</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="c1"># if isattr is True, the member is documented as an attribute</span>
            <span class="n">isattr</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># if the member __doc__ is the same as self&#39;s __doc__, it&#39;s just</span>
            <span class="c1"># inherited and therefore not the member&#39;s doc</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">cls</span><span class="p">:</span>
                <span class="n">cls_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cls_doc</span> <span class="o">==</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">doc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">has_doc</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

            <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">want_all</span> <span class="ow">and</span> <span class="n">membername</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">membername</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">membername</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># special __methods__</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">special_members</span> <span class="ow">is</span> <span class="n">ALL</span> <span class="ow">and</span> \
                        <span class="n">membername</span> <span class="o">!=</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">:</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="n">has_doc</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">undoc_members</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">special_members</span> <span class="ow">and</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">special_members</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ALL</span> <span class="ow">and</span> \
                        <span class="n">membername</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">special_members</span><span class="p">:</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="n">has_doc</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">undoc_members</span>
            <span class="k">elif</span> <span class="n">want_all</span> <span class="ow">and</span> <span class="n">membername</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
                <span class="c1"># ignore members whose name starts with _ by default</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">private_members</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="n">has_doc</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">undoc_members</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">membername</span><span class="p">)</span> <span class="ow">in</span> <span class="n">attr_docs</span><span class="p">:</span>
                <span class="c1"># keep documented attributes</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">isattr</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ignore undocumented members if :undoc-members: is not given</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">has_doc</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">undoc_members</span>

            <span class="c1"># give the user a chance to decide whether this member</span>
            <span class="c1"># should be skipped</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">app</span><span class="p">:</span>
                <span class="c1"># let extensions preprocess docstrings</span>
                <span class="n">skip_user</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">emit_firstresult</span><span class="p">(</span>
                    <span class="s1">&#39;autodoc-skip-member&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objtype</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span>
                    <span class="ow">not</span> <span class="n">keep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">skip_user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">skip_user</span>

            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">membername</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">isattr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">document_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_members</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; None</span>
        <span class="sd">&quot;&quot;&quot;Generate reST for member documentation.</span>

<span class="sd">        If *all_members* is True, do all members, else those given by</span>
<span class="sd">        *self.options.members*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set current namespace for finding members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">temp_data</span><span class="p">[</span><span class="s1">&#39;autodoc:module&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">temp_data</span><span class="p">[</span><span class="s1">&#39;autodoc:class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">want_all</span> <span class="o">=</span> <span class="n">all_members</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">inherited_members</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">members</span> <span class="ow">is</span> <span class="n">ALL</span>
        <span class="c1"># find out which members are documentable</span>
        <span class="n">members_check_module</span><span class="p">,</span> <span class="n">members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object_members</span><span class="p">(</span><span class="n">want_all</span><span class="p">)</span>

        <span class="c1"># remove members given by exclude-members</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">exclude_members</span><span class="p">:</span>
            <span class="n">members</span> <span class="o">=</span> <span class="p">[(</span><span class="n">membername</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">membername</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span> <span class="ow">in</span> <span class="n">members</span>
                       <span class="k">if</span> <span class="n">membername</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">exclude_members</span><span class="p">]</span>

        <span class="c1"># document non-skipped members</span>
        <span class="n">memberdocumenters</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[Tuple[Documenter, bool]]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">mname</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">isattr</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_members</span><span class="p">(</span><span class="n">members</span><span class="p">,</span> <span class="n">want_all</span><span class="p">):</span>
            <span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">itervalues</span><span class="p">(</span><span class="n">AutoDirective</span><span class="o">.</span><span class="n">_registry</span><span class="p">)</span>
                       <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">can_document_member</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">mname</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">classes</span><span class="p">:</span>
                <span class="c1"># don&#39;t know how to document this member</span>
                <span class="k">continue</span>
            <span class="c1"># prefer the documenter with the highest priority</span>
            <span class="n">classes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">cls</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
            <span class="c1"># give explicitly separated module name, so that members</span>
            <span class="c1"># of inner classes can be documented</span>
            <span class="n">full_mname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span> <span class="o">+</span> <span class="s1">&#39;::&#39;</span> <span class="o">+</span> \
                <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span> <span class="o">+</span> <span class="p">[</span><span class="n">mname</span><span class="p">])</span>
            <span class="n">documenter</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="p">,</span> <span class="n">full_mname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="p">)</span>
            <span class="n">memberdocumenters</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">documenter</span><span class="p">,</span> <span class="n">isattr</span><span class="p">))</span>
        <span class="n">member_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">member_order</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">autodoc_member_order</span>
        <span class="k">if</span> <span class="n">member_order</span> <span class="o">==</span> <span class="s1">&#39;groupwise&#39;</span><span class="p">:</span>
            <span class="c1"># sort by group; relies on stable sort to keep items in the</span>
            <span class="c1"># same group sorted alphabetically</span>
            <span class="n">memberdocumenters</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">member_order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">member_order</span> <span class="o">==</span> <span class="s1">&#39;bysource&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="p">:</span>
            <span class="c1"># sort by source order, by virtue of the module analyzer</span>
            <span class="n">tagorder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">tagorder</span>

            <span class="k">def</span> <span class="nf">keyfunc</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
                <span class="c1"># type: (Tuple[Documenter, bool]) -&gt; int</span>
                <span class="n">fullname</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;::&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">tagorder</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fullname</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tagorder</span><span class="p">))</span>
            <span class="n">memberdocumenters</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">keyfunc</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">documenter</span><span class="p">,</span> <span class="n">isattr</span> <span class="ow">in</span> <span class="n">memberdocumenters</span><span class="p">:</span>
            <span class="n">documenter</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span>
                <span class="n">all_members</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">real_modname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">real_modname</span><span class="p">,</span>
                <span class="n">check_module</span><span class="o">=</span><span class="n">members_check_module</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isattr</span><span class="p">)</span>

        <span class="c1"># reset current objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">temp_data</span><span class="p">[</span><span class="s1">&#39;autodoc:module&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">temp_data</span><span class="p">[</span><span class="s1">&#39;autodoc:class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">real_modname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">check_module</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">all_members</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (Any, str, bool, bool) -&gt; None</span>
        <span class="sd">&quot;&quot;&quot;Generate reST for the object given by *self.name*, and possibly for</span>
<span class="sd">        its members.</span>

<span class="sd">        If *more_content* is given, include that content. If *real_modname* is</span>
<span class="sd">        given, use that module name to find attribute docs. If *check_module* is</span>
<span class="sd">        True, only generate if the object is defined in the module name it is</span>
<span class="sd">        imported from. If *all_members* is True, document all members.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_name</span><span class="p">():</span>
            <span class="c1"># need a module to import</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;don</span><span class="se">\&#39;</span><span class="s1">t know which module to import for autodocumenting &#39;</span>
                <span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> (try placing a &quot;module&quot; or &quot;currentmodule&quot; directive &#39;</span>
                <span class="s1">&#39;in the document, or giving an explicit module name)&#39;</span>
                <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># now, import the module and get object to document</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">import_object</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c1"># If there is no real module defined, figure out which to use.</span>
        <span class="c1"># The real module is used in the module analyzer to look up the module</span>
        <span class="c1"># where the attribute documentation would actually be found in.</span>
        <span class="c1"># This is used for situations where you have a module that collects the</span>
        <span class="c1"># functions and classes of internal submodules.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_modname</span> <span class="o">=</span> <span class="n">real_modname</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_real_modname</span><span class="p">()</span>

        <span class="c1"># try to also get a source code analyzer for attribute docs</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">ModuleAnalyzer</span><span class="o">.</span><span class="n">for_module</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_modname</span><span class="p">)</span>
            <span class="c1"># parse right now, to get PycodeErrors on parsing (results will</span>
            <span class="c1"># be cached anyway)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">find_attr_docs</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">PycodeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] module analyzer failed: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
            <span class="c1"># no source file -- e.g. for builtin and C modules</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># at least add the module.__file__ as a dependency</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">,</span> <span class="s1">&#39;__file__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="vm">__file__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">filename_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">filename_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analyzer</span><span class="o">.</span><span class="n">srcname</span><span class="p">)</span>

        <span class="c1"># check __module__ of object (for members not given explicitly)</span>
        <span class="k">if</span> <span class="n">check_module</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_module</span><span class="p">():</span>
                <span class="k">return</span>

        <span class="n">sourcename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sourcename</span><span class="p">()</span>

        <span class="c1"># make sure that the result starts with an empty line.  This is</span>
        <span class="c1"># necessary for some situations where another directive preprocesses</span>
        <span class="c1"># reST and no starting newline is present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>

        <span class="c1"># format the object&#39;s signature, if any</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_signature</span><span class="p">()</span>

        <span class="c1"># generate the directive header and options, if applicable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_directive_header</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>

        <span class="c1"># e.g. the module directive doesn&#39;t have content</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">content_indent</span>

        <span class="c1"># add all content (from docstrings, attribute docs etc.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_content</span><span class="p">(</span><span class="n">more_content</span><span class="p">)</span>

        <span class="c1"># document members, if possible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document_members</span><span class="p">(</span><span class="n">all_members</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ModuleDocumenter</span><span class="p">(</span><span class="n">Documenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for modules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;module&#39;</span>
    <span class="n">content_indent</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;&#39;</span>
    <span class="n">titles_allowed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">option_spec</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;members&#39;</span><span class="p">:</span> <span class="n">members_option</span><span class="p">,</span> <span class="s1">&#39;undoc-members&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span>
        <span class="s1">&#39;noindex&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span> <span class="s1">&#39;inherited-members&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span>
        <span class="s1">&#39;show-inheritance&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span> <span class="s1">&#39;synopsis&#39;</span><span class="p">:</span> <span class="n">identity</span><span class="p">,</span>
        <span class="s1">&#39;platform&#39;</span><span class="p">:</span> <span class="n">identity</span><span class="p">,</span> <span class="s1">&#39;deprecated&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span>
        <span class="s1">&#39;member-order&#39;</span><span class="p">:</span> <span class="n">identity</span><span class="p">,</span> <span class="s1">&#39;exclude-members&#39;</span><span class="p">:</span> <span class="n">members_set_option</span><span class="p">,</span>
        <span class="s1">&#39;private-members&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span> <span class="s1">&#39;special-members&#39;</span><span class="p">:</span> <span class="n">members_option</span><span class="p">,</span>
        <span class="s1">&#39;imported-members&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span>
    <span class="p">}</span>  <span class="c1"># type: Dict[unicode, Callable]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="c1"># don&#39;t document submodules automatically</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># type: (str, Any, str, Any) -&gt; Tuple[str, List[unicode]]</span>
        <span class="k">if</span> <span class="n">modname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;&quot;::&quot; in automodule name doesn</span><span class="se">\&#39;</span><span class="s1">t make sense&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">path</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">base</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">parse_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; bool</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">Documenter</span><span class="o">.</span><span class="n">parse_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">retann</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;signature arguments or return annotation &#39;</span>
                                <span class="s1">&#39;given for automodule </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; None</span>
        <span class="n">Documenter</span><span class="o">.</span><span class="n">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

        <span class="n">sourcename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sourcename</span><span class="p">()</span>

        <span class="c1"># add some module-specific options</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">synopsis</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span>
                <span class="sa">u</span><span class="s1">&#39;   :synopsis: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">synopsis</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">platform</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span>
                <span class="sa">u</span><span class="s1">&#39;   :platform: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">deprecated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   :deprecated:&#39;</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_object_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">want_all</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; Tuple[bool, List[Tuple[unicode, object]]]</span>
        <span class="k">if</span> <span class="n">want_all</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__all__&#39;</span><span class="p">):</span>
                <span class="c1"># for implicit module members, check __module__ to avoid</span>
                <span class="c1"># documenting imported objects</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">safe_getmembers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">memberlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">__all__</span>
                <span class="c1"># Sometimes __all__ is broken...</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">memberlist</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> \
                   <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">memberlist</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;__all__ should be a list of strings, not </span><span class="si">%r</span><span class="s1"> &#39;</span>
                        <span class="s1">&#39;(in module </span><span class="si">%s</span><span class="s1">) -- ignoring __all__&#39;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">memberlist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
                    <span class="c1"># fall back to all members</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">safe_getmembers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">memberlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">members</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mname</span> <span class="ow">in</span> <span class="n">memberlist</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mname</span><span class="p">,</span> <span class="n">safe_getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="n">mname</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">directive</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;missing attribute mentioned in :members: or __all__: &#39;</span>
                    <span class="s1">&#39;module </span><span class="si">%s</span><span class="s1">, attribute </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">safe_getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;???&#39;</span><span class="p">),</span> <span class="n">mname</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">ModuleLevelDocumenter</span><span class="p">(</span><span class="n">Documenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for objects on module level (functions,</span>
<span class="sd">    classes, data/constants).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># type: (str, Any, str, Any) -&gt; Tuple[str, List[unicode]]</span>
        <span class="k">if</span> <span class="n">modname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">modname</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if documenting a toplevel object without explicit module,</span>
                <span class="c1"># it can be contained in another auto directive ...</span>
                <span class="n">modname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">temp_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;autodoc:module&#39;</span><span class="p">)</span>
                <span class="c1"># ... or in the scope of a module directive</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">modname</span><span class="p">:</span>
                    <span class="n">modname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">ref_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;py:module&#39;</span><span class="p">)</span>
                <span class="c1"># ... else, it stays None, which means invalid</span>
        <span class="k">return</span> <span class="n">modname</span><span class="p">,</span> <span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="n">base</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ClassLevelDocumenter</span><span class="p">(</span><span class="n">Documenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for objects on class level (methods,</span>
<span class="sd">    attributes).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modname</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># type: (str, Any, str, Any) -&gt; Tuple[str, List[unicode]]</span>
        <span class="k">if</span> <span class="n">modname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">mod_cls</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mod_cls</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># if documenting a class-level object without path,</span>
                <span class="c1"># there must be a current class, either from a parent</span>
                <span class="c1"># auto directive ...</span>
                <span class="n">mod_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">temp_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;autodoc:class&#39;</span><span class="p">)</span>
                <span class="c1"># ... or from a class directive</span>
                <span class="k">if</span> <span class="n">mod_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mod_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">ref_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;py:class&#39;</span><span class="p">)</span>
                <span class="c1"># ... if still None, there&#39;s no way to know</span>
                <span class="k">if</span> <span class="n">mod_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[]</span>
            <span class="n">modname</span><span class="p">,</span> <span class="bp">cls</span> <span class="o">=</span> <span class="n">rpartition</span><span class="p">(</span><span class="n">mod_cls</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
            <span class="c1"># if the module name is still missing, get it like above</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">modname</span><span class="p">:</span>
                <span class="n">modname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">temp_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;autodoc:module&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">modname</span><span class="p">:</span>
                <span class="n">modname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">ref_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;py:module&#39;</span><span class="p">)</span>
            <span class="c1"># ... else, it stays None, which means invalid</span>
        <span class="k">return</span> <span class="n">modname</span><span class="p">,</span> <span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="n">base</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">DocstringSignatureMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin for FunctionDocumenter and MethodDocumenter to provide the</span>
<span class="sd">    feature of reading the signature from the docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_find_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; Tuple[str, str]</span>
        <span class="n">docstrings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_doc</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_docstrings</span> <span class="o">=</span> <span class="n">docstrings</span><span class="p">[:]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">doclines</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">docstrings</span><span class="p">):</span>
            <span class="c1"># no lines in docstring, no match</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">doclines</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># match first line of docstring against signature RE</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">py_ext_sig_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">doclines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">exmod</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">retann</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
            <span class="c1"># the base name must match ours</span>
            <span class="n">valid_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ClassDocumenter</span><span class="p">):</span>
                <span class="n">valid_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__mro__&#39;</span><span class="p">):</span>
                    <span class="n">valid_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_names</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># re-prepare docstring to ignore more leading indentation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_docstrings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prepare_docstring</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">doclines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">args</span><span class="p">,</span> <span class="n">retann</span>
            <span class="c1"># don&#39;t look any further</span>
            <span class="k">break</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">get_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># type: (unicode, int) -&gt; List[List[unicode]]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_new_docstrings&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lines</span>
        <span class="k">return</span> <span class="n">Documenter</span><span class="o">.</span><span class="n">get_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">format_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">autodoc_docstring_signature</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># only act if a signature is not explicitly given already, and if</span>
            <span class="c1"># the feature is enabled</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_signature</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">retann</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">Documenter</span><span class="o">.</span><span class="n">format_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># type: ignore</span>


<span class="k">class</span> <span class="nc">DocstringStripSignatureMixin</span><span class="p">(</span><span class="n">DocstringSignatureMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin for AttributeDocumenter to provide the</span>
<span class="sd">    feature of stripping any function signature from the docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">format_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">autodoc_docstring_signature</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># only act if a signature is not explicitly given already, and if</span>
            <span class="c1"># the feature is enabled</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_signature</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Discarding _args is a only difference with</span>
                <span class="c1"># DocstringSignatureMixin.format_signature.</span>
                <span class="c1"># Documenter.format_signature use self.args value to format.</span>
                <span class="n">_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">retann</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">Documenter</span><span class="o">.</span><span class="n">format_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># type: ignore</span>


<span class="k">class</span> <span class="nc">FunctionDocumenter</span><span class="p">(</span><span class="n">DocstringSignatureMixin</span><span class="p">,</span> <span class="n">ModuleLevelDocumenter</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;function&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">30</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="k">return</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">member</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isbuiltin</span><span class="p">(</span><span class="n">member</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">format_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isbuiltin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="n">inspect</span><span class="o">.</span><span class="n">ismethoddescriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">):</span>
            <span class="c1"># cannot introspect arguments of a C function or method</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">argspec</span> <span class="o">=</span> <span class="n">getargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_builtin_class_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">)</span> <span class="ow">and</span>
               <span class="n">is_builtin_class_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> is a builtin class&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>

            <span class="c1"># if a class should be documented as function (yay duck</span>
            <span class="c1"># typing) we try to use the constructor signature as function</span>
            <span class="c1"># signature without the first argument.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">argspec</span> <span class="o">=</span> <span class="n">getargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">argspec</span> <span class="o">=</span> <span class="n">getargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">formatargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="o">*</span><span class="n">argspec</span><span class="p">)</span>
        <span class="c1"># escape backslashes for reST</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">document_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_members</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; None</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ClassDocumenter</span><span class="p">(</span><span class="n">DocstringSignatureMixin</span><span class="p">,</span> <span class="n">ModuleLevelDocumenter</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;class&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">option_spec</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;members&#39;</span><span class="p">:</span> <span class="n">members_option</span><span class="p">,</span> <span class="s1">&#39;undoc-members&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span>
        <span class="s1">&#39;noindex&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span> <span class="s1">&#39;inherited-members&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span>
        <span class="s1">&#39;show-inheritance&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span> <span class="s1">&#39;member-order&#39;</span><span class="p">:</span> <span class="n">identity</span><span class="p">,</span>
        <span class="s1">&#39;exclude-members&#39;</span><span class="p">:</span> <span class="n">members_set_option</span><span class="p">,</span>
        <span class="s1">&#39;private-members&#39;</span><span class="p">:</span> <span class="n">bool_option</span><span class="p">,</span> <span class="s1">&#39;special-members&#39;</span><span class="p">:</span> <span class="n">members_option</span><span class="p">,</span>
    <span class="p">}</span>  <span class="c1"># type: Dict[unicode, Callable]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">class_types</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; Any</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ModuleLevelDocumenter</span><span class="o">.</span><span class="n">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># if the class is documented under another name, document it</span>
        <span class="c1"># as data/attribute</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">doc_as_attr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objpath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">doc_as_attr</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">format_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="c1"># for classes, the relevant signature is the __init__ method&#39;s</span>
        <span class="n">initmeth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># classes without __init__ method, default __init__ or</span>
        <span class="c1"># __init__ written in C?</span>
        <span class="k">if</span> <span class="n">initmeth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
                <span class="n">is_builtin_class_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="ow">not</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">initmeth</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">initmeth</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">argspec</span> <span class="o">=</span> <span class="n">getargspec</span><span class="p">(</span><span class="n">initmeth</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># still not possible: happens e.g. for old-style classes</span>
            <span class="c1"># with __init__ in C</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="s1">&#39;self&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">formatargspec</span><span class="p">(</span><span class="n">initmeth</span><span class="p">,</span> <span class="o">*</span><span class="n">argspec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">format_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_as_attr</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

        <span class="k">return</span> <span class="n">DocstringSignatureMixin</span><span class="o">.</span><span class="n">format_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_as_attr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directivetype</span> <span class="o">=</span> <span class="s1">&#39;attribute&#39;</span>
        <span class="n">Documenter</span><span class="o">.</span><span class="n">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

        <span class="c1"># add inheritance info, if wanted</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_as_attr</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">show_inheritance</span><span class="p">:</span>
            <span class="n">sourcename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sourcename</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__bases__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">):</span>
                <span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="vm">__module__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;__builtin__&#39;</span><span class="p">,</span> <span class="s1">&#39;builtins&#39;</span><span class="p">)</span> <span class="ow">and</span>
                         <span class="sa">u</span><span class="s1">&#39;:class:`</span><span class="si">%s</span><span class="s1">`&#39;</span> <span class="o">%</span> <span class="n">b</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">or</span>
                         <span class="sa">u</span><span class="s1">&#39;:class:`</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">`&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   &#39;</span> <span class="o">+</span> <span class="n">_</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;Bases: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bases</span><span class="p">),</span>
                              <span class="n">sourcename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># type: (unicode, int) -&gt; List[List[unicode]]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_new_docstrings&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lines</span>

        <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">autoclass_content</span>

        <span class="n">docstrings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">attrdocstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attrdocstring</span><span class="p">:</span>
            <span class="n">docstrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attrdocstring</span><span class="p">)</span>

        <span class="c1"># for classes, what the &quot;docstring&quot; is can be controlled via a</span>
        <span class="c1"># config value; the default is only the class docstring</span>
        <span class="k">if</span> <span class="n">content</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">):</span>
            <span class="n">initdocstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">)</span>
            <span class="c1"># for new-style classes, no __init__ means default __init__</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">initdocstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">initdocstring</span> <span class="o">==</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span>  <span class="c1"># for pypy</span>
                 <span class="n">initdocstring</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)):</span>  <span class="c1"># for !pypy</span>
                <span class="n">initdocstring</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">initdocstring</span><span class="p">:</span>
                <span class="c1"># try __new__</span>
                <span class="n">initdocstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">)</span>
                <span class="c1"># for new-style classes, no __new__ means default __new__</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">initdocstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">initdocstring</span> <span class="o">==</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span>  <span class="c1"># for pypy</span>
                     <span class="n">initdocstring</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)):</span>  <span class="c1"># for !pypy</span>
                    <span class="n">initdocstring</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">initdocstring</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">content</span> <span class="o">==</span> <span class="s1">&#39;init&#39;</span><span class="p">:</span>
                    <span class="n">docstrings</span> <span class="o">=</span> <span class="p">[</span><span class="n">initdocstring</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">docstrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">initdocstring</span><span class="p">)</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">docstring</span> <span class="ow">in</span> <span class="n">docstrings</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="n">text_type</span><span class="p">):</span>
                <span class="n">doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prepare_docstring</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="n">ignore</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># this will not trigger on Py3</span>
                <span class="n">doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prepare_docstring</span><span class="p">(</span><span class="n">force_decode</span><span class="p">(</span><span class="n">docstring</span><span class="p">,</span> <span class="n">encoding</span><span class="p">),</span>
                                             <span class="n">ignore</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="p">,</span> <span class="n">no_docstring</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (Any, bool) -&gt; None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_as_attr</span><span class="p">:</span>
            <span class="n">classname</span> <span class="o">=</span> <span class="n">safe_getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">classname</span><span class="p">:</span>
                <span class="n">content</span> <span class="o">=</span> <span class="n">ViewList</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;alias of :class:`</span><span class="si">%s</span><span class="s1">`&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">classname</span><span class="p">],</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">ModuleLevelDocumenter</span><span class="o">.</span><span class="n">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span>
                                                  <span class="n">no_docstring</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ModuleLevelDocumenter</span><span class="o">.</span><span class="n">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">document_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_members</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_as_attr</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">ModuleLevelDocumenter</span><span class="o">.</span><span class="n">document_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_members</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ExceptionDocumenter</span><span class="p">(</span><span class="n">ClassDocumenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized ClassDocumenter subclass for exceptions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;exception&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="c1"># needs a higher priority than ClassDocumenter</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">class_types</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">issubclass</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="ne">BaseException</span><span class="p">)</span>  <span class="c1"># type: ignore</span>


<span class="k">class</span> <span class="nc">DataDocumenter</span><span class="p">(</span><span class="n">ModuleLevelDocumenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for data items.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;data&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
    <span class="n">option_spec</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ModuleLevelDocumenter</span><span class="o">.</span><span class="n">option_spec</span><span class="p">)</span>
    <span class="n">option_spec</span><span class="p">[</span><span class="s2">&quot;annotation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotation_option</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">ModuleDocumenter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isattr</span>

    <span class="k">def</span> <span class="nf">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; None</span>
        <span class="n">ModuleLevelDocumenter</span><span class="o">.</span><span class="n">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
        <span class="n">sourcename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sourcename</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">objrepr</span> <span class="o">=</span> <span class="n">object_description</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   :annotation: = &#39;</span> <span class="o">+</span> <span class="n">objrepr</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">annotation</span> <span class="ow">is</span> <span class="n">SUPPRESS</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   :annotation: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span>
                          <span class="n">sourcename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">document_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_members</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; None</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MethodDocumenter</span><span class="p">(</span><span class="n">DocstringSignatureMixin</span><span class="p">,</span> <span class="n">ClassLevelDocumenter</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for methods (normal, static and class).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;method&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># must be more than FunctionDocumenter</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="k">return</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isroutine</span><span class="p">(</span><span class="n">member</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">ModuleDocumenter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; Any</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ClassLevelDocumenter</span><span class="o">.</span><span class="n">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># to distinguish classmethod/staticmethod</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directivetype</span> <span class="o">=</span> <span class="s1">&#39;classmethod&#39;</span>
            <span class="c1"># document class and static members before ordinary ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">member_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">member_order</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directivetype</span> <span class="o">=</span> <span class="s1">&#39;staticmethod&#39;</span>
            <span class="c1"># document class and static members before ordinary ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">member_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">member_order</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directivetype</span> <span class="o">=</span> <span class="s1">&#39;method&#39;</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">format_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; unicode</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isbuiltin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="n">inspect</span><span class="o">.</span><span class="n">ismethoddescriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">):</span>
            <span class="c1"># can never get arguments of a C function or method</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">argspec</span> <span class="o">=</span> <span class="n">getargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="s1">&#39;self&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">formatargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="o">*</span><span class="n">argspec</span><span class="p">)</span>
        <span class="c1"># escape backslashes for reST</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">document_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_members</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; None</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">AttributeDocumenter</span><span class="p">(</span><span class="n">DocstringStripSignatureMixin</span><span class="p">,</span> <span class="n">ClassLevelDocumenter</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;attribute&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">60</span>
    <span class="n">option_spec</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ModuleLevelDocumenter</span><span class="o">.</span><span class="n">option_spec</span><span class="p">)</span>
    <span class="n">option_spec</span><span class="p">[</span><span class="s2">&quot;annotation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotation_option</span>

    <span class="c1"># must be higher than the MethodDocumenter, else it will recognize</span>
    <span class="c1"># some non-data descriptors as methods</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_function_or_method</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isbuiltin</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="n">non_attr_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">MethodDescriptorType</span><span class="p">)</span>
        <span class="n">isdatadesc</span> <span class="o">=</span> <span class="n">isdescriptor</span><span class="p">(</span><span class="n">member</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> \
            <span class="bp">cls</span><span class="o">.</span><span class="n">is_function_or_method</span><span class="p">(</span><span class="n">member</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> \
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">non_attr_types</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> \
            <span class="nb">type</span><span class="p">(</span><span class="n">member</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;instancemethod&quot;</span>
        <span class="c1"># That last condition addresses an obscure case of C-defined</span>
        <span class="c1"># methods using a deprecated type in Python 3, that is not otherwise</span>
        <span class="c1"># exported anywhere by Python</span>
        <span class="k">return</span> <span class="n">isdatadesc</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">ModuleDocumenter</span><span class="p">)</span> <span class="ow">and</span>
                              <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isroutine</span><span class="p">(</span><span class="n">member</span><span class="p">)</span> <span class="ow">and</span>
                              <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">class_types</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">document_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_members</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (bool) -&gt; None</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; Any</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ClassLevelDocumenter</span><span class="o">.</span><span class="n">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isenumattribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">isdescriptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_function_or_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_datadescriptor</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if it&#39;s not a data descriptor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_datadescriptor</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">get_real_modname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; str</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">modname</span>

    <span class="k">def</span> <span class="nf">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; None</span>
        <span class="n">ClassLevelDocumenter</span><span class="o">.</span><span class="n">add_directive_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
        <span class="n">sourcename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sourcename</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datadescriptor</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">objrepr</span> <span class="o">=</span> <span class="n">object_description</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   :annotation: = &#39;</span> <span class="o">+</span> <span class="n">objrepr</span><span class="p">,</span> <span class="n">sourcename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">annotation</span> <span class="ow">is</span> <span class="n">SUPPRESS</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;   :annotation: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span>
                          <span class="n">sourcename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="p">,</span> <span class="n">no_docstring</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (Any, bool) -&gt; None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datadescriptor</span><span class="p">:</span>
            <span class="c1"># if it&#39;s not a data descriptor, its docstring is very probably the</span>
            <span class="c1"># wrong thing to display</span>
            <span class="n">no_docstring</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ClassLevelDocumenter</span><span class="o">.</span><span class="n">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="p">,</span> <span class="n">no_docstring</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">InstanceAttributeDocumenter</span><span class="p">(</span><span class="n">AttributeDocumenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized Documenter subclass for attributes that cannot be imported</span>
<span class="sd">    because they are instance attributes (e.g. assigned in __init__).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;instanceattribute&#39;</span>
    <span class="n">directivetype</span> <span class="o">=</span> <span class="s1">&#39;attribute&#39;</span>
    <span class="n">member_order</span> <span class="o">=</span> <span class="mi">60</span>

    <span class="c1"># must be higher than AttributeDocumenter</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="mi">11</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_document_member</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">membername</span><span class="p">,</span> <span class="n">isattr</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="c1"># type: (Any, unicode, bool, Any) -&gt; bool</span>
        <span class="sd">&quot;&quot;&quot;This documents only INSTANCEATTR members.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">isattr</span> <span class="ow">and</span> <span class="p">(</span><span class="n">member</span> <span class="ow">is</span> <span class="n">INSTANCEATTR</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">import_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; bool</span>
        <span class="sd">&quot;&quot;&quot;Never import anything.&quot;&quot;&quot;</span>
        <span class="c1"># disguise as an attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;attribute&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datadescriptor</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="p">,</span> <span class="n">no_docstring</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># type: (Any, bool) -&gt; None</span>
        <span class="sd">&quot;&quot;&quot;Never try to get a docstring from the object.&quot;&quot;&quot;</span>
        <span class="n">AttributeDocumenter</span><span class="o">.</span><span class="n">add_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">more_content</span><span class="p">,</span> <span class="n">no_docstring</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AutoDirective</span><span class="p">(</span><span class="n">Directive</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The AutoDirective class is used for all autodoc directives.  It dispatches</span>
<span class="sd">    most of the work to one of the Documenters, which it selects through its</span>
<span class="sd">    *_registry* dictionary.</span>

<span class="sd">    The *_special_attrgetters* attribute is used to customize ``getattr()``</span>
<span class="sd">    calls that the Documenters make; its entries are of the form ``type:</span>
<span class="sd">    getattr_function``.</span>

<span class="sd">    Note: When importing an object, all items along the import chain are</span>
<span class="sd">    accessed using the descendant&#39;s *_special_attrgetters*, thus this</span>
<span class="sd">    dictionary should include all necessary functions for accessing</span>
<span class="sd">    attributes of the parents.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># a registry of objtype -&gt; documenter class</span>
    <span class="n">_registry</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># type: Dict[unicode, Type[Documenter]]</span>

    <span class="c1"># a registry of type -&gt; getattr function</span>
    <span class="n">_special_attrgetters</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># type: Dict[Type, Callable]</span>

    <span class="c1"># flags that can be given in autodoc_default_flags</span>
    <span class="n">_default_flags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
        <span class="s1">&#39;members&#39;</span><span class="p">,</span> <span class="s1">&#39;undoc-members&#39;</span><span class="p">,</span> <span class="s1">&#39;inherited-members&#39;</span><span class="p">,</span> <span class="s1">&#39;show-inheritance&#39;</span><span class="p">,</span>
        <span class="s1">&#39;private-members&#39;</span><span class="p">,</span> <span class="s1">&#39;special-members&#39;</span><span class="p">,</span>
    <span class="p">])</span>

    <span class="c1"># standard docutils directive settings</span>
    <span class="n">has_content</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">required_arguments</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">optional_arguments</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">final_argument_whitespace</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># allow any options to be passed; the options are parsed further</span>
    <span class="c1"># by the selected Documenter</span>
    <span class="n">option_spec</span> <span class="o">=</span> <span class="n">DefDict</span><span class="p">(</span><span class="n">identity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="c1"># type: (unicode) -&gt; None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reporter</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># type: () -&gt; List[nodes.Node]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>   <span class="c1"># type: Set[unicode]</span>
                                    <span class="c1"># a set of dependent filenames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reporter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">document</span><span class="o">.</span><span class="n">reporter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">document</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[unicode]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">ViewList</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">source</span><span class="p">,</span> <span class="n">lineno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reporter</span><span class="o">.</span><span class="n">get_source_and_line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">lineno</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] </span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">: input:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                     <span class="n">source</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_text</span><span class="p">)</span>

        <span class="c1"># find out what documenter to call</span>
        <span class="n">objtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        <span class="n">doc_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registry</span><span class="p">[</span><span class="n">objtype</span><span class="p">]</span>
        <span class="c1"># add default flags</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_flags</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc_class</span><span class="o">.</span><span class="n">option_spec</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">negated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;no-&#39;</span> <span class="o">+</span> <span class="n">flag</span><span class="p">,</span> <span class="s1">&#39;not given&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">autodoc_default_flags</span> <span class="ow">and</span> \
               <span class="ow">not</span> <span class="n">negated</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># process the options with the selected documenter&#39;s option_spec</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genopt</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span><span class="n">assemble_option_dict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">doc_class</span><span class="o">.</span><span class="n">option_spec</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># an option is either unknown or has a wrong type</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reporter</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;An option to </span><span class="si">%s</span><span class="s1"> is either unknown or &#39;</span>
                                      <span class="s1">&#39;has an invalid value: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">),</span>
                                      <span class="n">line</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">msg</span><span class="p">]</span>
        <span class="c1"># generate the output</span>
        <span class="n">documenter</span> <span class="o">=</span> <span class="n">doc_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">documenter</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">more_content</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[autodoc] output:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">))</span>

        <span class="c1"># record all filenames as dependencies -- this will at least</span>
        <span class="c1"># partially make automatic invalidation possible</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename_set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">document</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">record_dependencies</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

        <span class="c1"># use a custom reporter that correctly assigns lines to source</span>
        <span class="c1"># filename/description and lineno</span>
        <span class="n">old_reporter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">memo</span><span class="o">.</span><span class="n">reporter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">memo</span><span class="o">.</span><span class="n">reporter</span> <span class="o">=</span> <span class="n">AutodocReporter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">memo</span><span class="o">.</span><span class="n">reporter</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">documenter</span><span class="o">.</span><span class="n">titles_allowed</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
            <span class="c1"># necessary so that the child nodes get the right source/line set</span>
            <span class="n">node</span><span class="o">.</span><span class="n">document</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">document</span>
            <span class="n">nested_parse_with_titles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">paragraph</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">document</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">document</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">nested_parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">memo</span><span class="o">.</span><span class="n">reporter</span> <span class="o">=</span> <span class="n">old_reporter</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">warnings</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span>


<span class="k">def</span> <span class="nf">add_documenter</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="c1"># type: (Type[Documenter]) -&gt; None</span>
    <span class="sd">&quot;&quot;&quot;Register a new Documenter.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Documenter</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ExtensionError</span><span class="p">(</span><span class="s1">&#39;autodoc documenter </span><span class="si">%r</span><span class="s1"> must be a subclass &#39;</span>
                             <span class="s1">&#39;of Documenter&#39;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="c1"># actually, it should be possible to override Documenters</span>
    <span class="c1"># if cls.objtype in AutoDirective._registry:</span>
    <span class="c1">#    raise ExtensionError(&#39;autodoc documenter for %r is already &#39;</span>
    <span class="c1">#                         &#39;registered&#39; % cls.objtype)</span>
    <span class="n">AutoDirective</span><span class="o">.</span><span class="n">_registry</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">objtype</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>


<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="c1"># type: (Sphinx) -&gt; Dict[unicode, Any]</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">ModuleDocumenter</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">ClassDocumenter</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">ExceptionDocumenter</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">DataDocumenter</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">FunctionDocumenter</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">MethodDocumenter</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">AttributeDocumenter</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_autodocumenter</span><span class="p">(</span><span class="n">InstanceAttributeDocumenter</span><span class="p">)</span>

    <span class="n">app</span><span class="o">.</span><span class="n">add_config_value</span><span class="p">(</span><span class="s1">&#39;autoclass_content&#39;</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_config_value</span><span class="p">(</span><span class="s1">&#39;autodoc_member_order&#39;</span><span class="p">,</span> <span class="s1">&#39;alphabetic&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_config_value</span><span class="p">(</span><span class="s1">&#39;autodoc_default_flags&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_config_value</span><span class="p">(</span><span class="s1">&#39;autodoc_docstring_signature&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_config_value</span><span class="p">(</span><span class="s1">&#39;autodoc_mock_imports&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_event</span><span class="p">(</span><span class="s1">&#39;autodoc-process-docstring&#39;</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_event</span><span class="p">(</span><span class="s1">&#39;autodoc-process-signature&#39;</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">add_event</span><span class="p">(</span><span class="s1">&#39;autodoc-skip-member&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">sphinx</span><span class="o">.</span><span class="n">__display_version__</span><span class="p">,</span> <span class="s1">&#39;parallel_read_safe&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">testcls</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;test doc string&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># type: (Any) -&gt; Any</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="c1"># type: (Any, Any) -&gt; None</span>
        <span class="sd">&quot;&quot;&quot;Attr setter.&quot;&quot;&quot;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../master.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Saikiran Yerraguntla.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>